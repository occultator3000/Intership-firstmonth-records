## 外层 ScrollView + 吸顶导航栏 + 可横向滑动标签栏：

使用`stickyHeaderIndices`让导航栏悬浮后，导航栏内部的横向ScrollView]会失去响应能力，无法进行手势滑动。这是因为外层的纵向ScrollView会拦截所有触摸事件，导致内部的横向滚动无法正常工作。

### 方案一

创建两个相同的导航组件：一个作为原始导航栏嵌入在滚动内容中，另一个作为悬浮导航栏通过绝对定位放置在页面顶部，通过监听滚动位置手动控制悬浮导航的显隐。

~~~typescript
// 双导航栏架构
<View style={styles.container}>
  <ScrollView ref={scrollViewRef}>
    {/* 原始导航栏 - 在滚动内容中 */}
    <SceneNavigationViewComponent
      ref={navigationRef}
      tags={navigationTags}
      onTagPress={handleTagPress}
    />
    {/* 其他内容 */}
  </ScrollView>
  
  {/* 悬浮导航栏 - 绝对定位 */}
  <View ref={floatingNavigationDockRef} style={styles.floatingNavigation}>
    <SceneNavigationViewComponent
      ref={floatingNavigationRef}
      tags={navigationTags}
      onTagPress={handleTagPress}
    />
  </View>
</View>
~~~

关键实现细节

#### 滚动监听与悬浮控制

通过监听主ScrollView的滚动事件，当滚动位置超过预设的临界值时，使用setNativeProps方法控制悬浮导航的透明度和层级。这种方法避免了重新渲染，保证了流畅的动画效果。

~~~typescript
const navigationStickyThreshold = 280; // 头图高度 + 标题高度

const setFloatingNavigationOpacity = useCallback((opacity: number) => {
  floatingNavigationDockRef.current?.setNativeProps({
    opacity,
    zIndex: opacity >= 1 ? 100 : -1,
  });
}, []);

onScroll={event => {
  const offsetY = event.nativeEvent.contentOffset.y;
  if (offsetY >= navigationStickyThreshold) {
    setFloatingNavigationOpacity(1);
  } else {
    setFloatingNavigationOpacity(0);
  }
}}
~~~

#### 导航状态同步

两个导航栏需要保持状态完全同步，包括选中状态和滚动位置。当用户点击任一导航栏的标签时，都会同时更新两个导航栏的状态，并且会自动滚动到对应的商品分组位置。

~~~typescript
const handleTagPress = useCallback((tag: GroupTitleData, _index: number) => {
  if (tag.categoryId) {
    // 滚动到对应商品组
    const sectionRef = sectionRefs.current[tag.categoryId];
    if (sectionRef && scrollViewRef.current) {
      sectionRef.measureLayout(
        scrollViewRef.current as any,
        (_x: number, y: number) => {
          const targetY = Math.max(0, y - 120);
          scrollViewRef.current?.scrollTo({ y: targetY, animated: true });
        }
      );
    }
    
    // 同步两个导航栏状态
    setSelectedCategoryId(tag.categoryId);
    navigationRef.current?.scrollToTag(tag.categoryId);
    floatingNavigationRef.current?.scrollToTag(tag.categoryId);
  }
}, []);
~~~

#### 导航组件设计

导航组件使用`forwardRef`和`useImperativeHandle`暴露方法给父组件调用，支持外部控制滚动位置和内容偏移。内部使用横向ScrollView实现标签的滑动效果，通过合理的触摸事件配置确保手势响应正常。

~~~typescript
export const SceneNavigationViewComponent = forwardRef<
  SceneNavigationViewComponentRef,
  ISceneNavigationViewComponentProps
>((props, ref) => {
  const scrollRef = useRef<ScrollView>(null);
  
  useImperativeHandle(ref, () => ({
    scrollToTag: (categoryId: string) => {
      // 滚动到指定标签位置的实现
    },
    setContentOffset: (contentOffset: number) => {
      // 同步滚动偏移的实现
    },
  }));

  return (
    <View style={styles.navigationContainer}>
      <ScrollView
        ref={scrollRef}
        horizontal
        showsHorizontalScrollIndicator={false}
        scrollEnabled={true}
        nestedScrollEnabled={true}
        onStartShouldSetResponder={() => true}
      >
        {/* 标签列表渲染 */}
      </ScrollView>
    </View>
  );
});
~~~

#### 性能优化考虑

整个解决方案注重性能优化。使用useCallback缓存事件处理函数，使用useMemo缓存计算结果，通过setNativeProps进行高性能的样式更新，避免不必要的组件重渲染。同时设置合适的scrollEventThrottle值来控制滚动事件的触发频率。

~~~typescript
// 缓存导航标签数据
const navigationTags = useMemo(() => {
  return mockNavigationTags.map(tag => ({
    ...tag,
    isSelected: tag.categoryId === selectedCategoryId,
  }));
}, [selectedCategoryId]);

// 优化滚动事件处理
scrollEventThrottle={16} // 约60fps的更新频率
~~~

避开React Native的嵌套滚动限制，通过双导航栏架构和手动控制显隐的方式，可以解决scrollView的手势嵌套问题，但明显性能上不合适

### 方案二 

IndexScrollView 是一个专门解决React Native中嵌套滚动冲突和精准索引定位的高级滚动组件。不同于普通的ScrollView，通过维护布局缓存和索引映射来实现高性能的滚动控制和精确的元素定位功能。

#### 维护状态

组件内部使用了三个关键的ref来维护状态，这些ref避免了频繁的重渲染，保证了滚动的流畅性。

~~~typescript
const scrollRef = React.useRef<ScrollView>(null);
const layouts = React.useRef(new Map<number, LayoutRectangle>());
const focusedIndex = React.useRef(-1);
const containerSize = React.useRef({ width: 0, height: 0 });
const contentSize = React.useRef({ width: 0, height: 0 });
~~~

Layouts是整个组件的核心，它使用Map数据结构缓存每个子项的布局信息。当需要滚动到特定索引时，组件直接从缓存中获取目标位置，而不需要重新计算或测量

#### 布局缓存机制

每个子项都被包装在Pressable组件中，通过onLayout回调来收集布局信息。这种设计让组件能够精确知道每个元素的位置和尺寸。

~~~typescript
{data?.map((item, index) => (
  <Pressable
    key={index}
    onPress={() => onIndexChanged?.(index, item)}
    onLayout={e => {
      renderItemLayout?.(index, e.nativeEvent.layout);
      layouts.current.set(index, e.nativeEvent.layout);
      if (focusedIndex.current !== currentIndex && currentIndex === index) {
        scrollToIndex(index);
      }
    }}
  >
    {renderItem(item, index, currentIndex === index)}
  </Pressable>
))}
~~~

当布局发生变化时，组件会自动更新缓存，并且如果当前应该聚焦的索引与实际聚焦的索引不符，会自动触发滚动到正确位置。这种自适应机制确保了在动态内容变化时组件仍能保持正确的状态

#### 滚动定位算法

这个算法支持两种滚动模式。在普通模式下，目标元素会滚动到视口的起始位置；在centerItem模式下，目标元素会滚动到视口的中心位置。计算公式考虑了容器尺寸和目标元素尺寸的差值，确保居中效果的准确性。

~~~typescript
const scrollToIndex = React.useCallback(
  (index: number) => {
    const layout = layouts.current.get(index);
    if (layout) {
      focusedIndex.current = index;
      scrollRef.current?.scrollTo({
        x: horizontal ? layout.x - (centerItem && index !== 0 ? (containerSize.current.width - layout.width) / 2 : 0) : 0,
        y: !horizontal ? layout.y - (centerItem && index !== 0 ? (containerSize.current.height - layout.height) / 2 : 0) : 0,
        animated: animateIndexChange,
      });
    }
  },
  [animateIndexChange, horizontal, centerItem],
);
~~~

**useImperativeHandle**暴露了scrollToOffset方法，允许父组件直接控制滚动位置。useEffect监听currentIndex的变化，当索引改变时自动滚动到新位置，但在itemWidthFix模式下会跳过这个自动滚动，这是为了处理动态宽度元素的特殊情况。

~~~typescript
React.useImperativeHandle(ref, () => ({
  scrollToOffset: (offset: number, animated: boolean) => {
    scrollRef.current?.scrollTo({ x: horizontal ? offset : 0, y: !horizontal ? offset : 0, animated });
  },
}));

React.useEffect(() => {
  if (!itemWidthFix) {
    scrollToIndex(currentIndex);
  }
}, [currentIndex, scrollToIndex, contentInsetToBottom, itemWidthFix]);
~~~

#### 优化

组件通过特定的ScrollView配置来优化嵌套滚动的性能和兼容性,确保滚动行为在不同平台上的一致性，避免嵌套滚动时出现意外的偏移。

~~~typescript
<ScrollView
  ref={scrollRef}
  overScrollMode="never" //禁用了Android上的过度滚动效果
  automaticallyAdjustContentInsets={false}//禁用了iOS的自动内容边距调整
  contentInset={{ top: 0, bottom: contentInsetToBottom, left: 0, right: 0 }}
  horizontal={horizontal}
  bounces={bounces}
  {...rest}
>
~~~

#### 滚动冲突问题：

当点击标签时，会触发以下连锁反应：

1. 点击标签 → 设置选中状态 → 主页面滚动到目标分组
2. 主页面滚动 → 触发onScroll事件 → detectCurrentSection检测当前分组
3. 如果检测的分组与点击的不一致 → 又会更新标签选中状态 → 可能再次触发滚动

这就造成了"横跳"现象

##### 防抖动策略

1. **点击滚动标记法** - 核心防抖机制

~~~typescript
const isClickScrolling = useRef<boolean>(false);

// 点击时禁止检测
const handleTagPress = useCallback((tag, index) => {
  isClickScrolling.current = true; // 禁止检测
  console.log('开始点击滚动，禁止检测');
  
  // 执行滚动...
  
  // 500ms后恢复检测
  setTimeout(() => {
    isClickScrolling.current = false; // 恢复检测
    console.log('点击滚动完成，恢复检测');
  }, 500);
}, []);

// 检测时跳过点击期间
const detectCurrentSectionWithDebounce = useCallback((scrollY) => {
  if (isClickScrolling.current) return; // 点击时直接跳过
  // ...检测逻辑
}, []);
~~~

2. **索引缓存对比法** - 减少频繁更新

~~~typescript
const focusedIndex = useRef<number>(0);

// 只有索引变化时才更新状态
if (currentIndex !== focusedIndex.current) {
  focusedIndex.current = currentIndex; // 更新缓存
  setSelectedCategoryId(currentCategoryId); // 减少状态更新频率
}
~~~

3. **统一偏移计算法** - 避免数值差异

~~~typescript
//  统一的计算公式
const calculateScrollOffset = useCallback((position: number) => {
  const navigationHeight = 120;
  return Math.max(0, position - navigationHeight);
}, []);

// 点击滚动使用
const targetY = calculateScrollOffset(cachedPosition);

// 检测触发也使用
const triggerPoint = calculateScrollOffset(position);
~~~

4. **位置预缓存法** - 避免实时测量抖动

~~~typescript
const sectionPositions = useRef<Record<string, number>>({});

// 预先缓存所有位置
const cacheAllSectionPositions = useCallback(() => {
  allProducts.forEach((category) => {
    sectionRef?.measureLayout(scrollViewRef.current, (x, y) => {
      sectionPositions.current[category.categoryId] = y; // 缓存位置
    });
  });
}, []);

// 使用缓存位置，避免重复测量
const cachedPosition = sectionPositions.current[tag.categoryId];
~~~

5. **重复调用检查法** - 防止无意义操作

~~~typescript
// 检查是否需要重复滚动
if (focusedIndex.current === index && selectedCategoryId === tag.categoryId) {
  console.log('目标分组已经是当前聚焦分组，跳过滚动');
  return; // 直接跳过
}
~~~

6. **防抖定时器优化** - 减少计算频率

~~~typescript
const scrollDetectionTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

// 设置定时器
if (scrollDetectionTimer.current) {
  clearTimeout(scrollDetectionTimer.current);
}

scrollDetectionTimer.current = setTimeout(() => {
  // 执行检测逻辑
}, 0); // 几乎立即执行，主要用于合并同一帧的多次调用
~~~

**完整的防抖流程**

~~~typescript
用户点击导航标签
        ↓
isClickScrolling = true (禁止检测)
        ↓
更新 focusedIndex 缓存
        ↓
使用统一公式计算目标位置
        ↓
优先使用缓存位置
        ↓
执行滚动动画
        ↓
500ms 后恢复检测
        ↓
isClickScrolling = false (恢复检测)
~~~

### 效果：

![横向导航器](/Users/pupu/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/nt_qq_77198b1440654beb5771fdf440757b73/nt_data/Pic/2025-08/Ori/55507a1f3a77804130a8607d8f463ed3.gif)
