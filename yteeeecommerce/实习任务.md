# 实习任务

## 第一个月：

 ### 1、开发环境搭建、熟悉git使用、熟悉Charles、VS Code、Android Studio、sourceTree等工具的使用 

### 2、RN学习，掌握js、TypeScript语言基础及语法

###  3、整理学习笔记并总结心得体会 

#### RN的学习

##### 1. React Native 环境搭建

**学习文档参考：**

[RN项目快速上手](https://github.com/reactnativecn/react-native-website/blob/production/archived_docs/version-0.68/_getting-started-macos-android.md)



- 1.1 HomeBrew、Node、Yarn/NPM 、JDK、Android Studio安装

- 1.2 React Native CLI 安装与初始化项目：`npx react-native init YOUR-PROJECT`

- 1.3 Android 环境配置（Xcode、Android Studio、模拟器/真机）
  
  - 使用Virtual Device 
  - 使用真机设备
    - 项目运行调试：
    
    ~~~
    # 查看设备
    adb devices
    
    # 运行设备
    npx react-native run-android
    
    #选择设备运行
    npx react-native run-android --deviceId emulator-5554
    ~~~
    
    - 手机上报错误查看：`adb logcat | grep -i react`
  
- 1.4 Metro 服务与缓存管理
  - 开启Metro 
  
    ~~~
    npx react-native start           # 启动 Metro
    npx react-native start --reset-cache  # 强制清理缓存
    ~~~
  
  - 项目彻底清理和重新编译
  
    ~~~
    # 1. 删除 node_modules
    rm -rf node_modules
    
    # 2. 删除 android 构建缓存
    rm -rf android/build
    rm -rf android/app/build
    
    # 3. 再次安装依赖
    yarn install
    # 或 npm install
    
    # 4. 清理 gradle
    cd android
    ./gradlew clean
    cd ..
    
    # 5. 重启 Metro
    npx react-native start --reset-cache
    
    # 6. 重新编译安装
    npx react-native run-android
    ~~~
    
  - commands ：
  
    ~~~
       r  - reload app(s)
       d  - open Dev Menu
       j  - open DevTools
    ~~~

##### 2. React Native 组件基础

**学习文档参考：**

[RN官网](https://www.react-native.cn/docs/turbo-native-modules-introduction)

[React Hooks](https://zh-hans.react.dev/reference/react/hooks)

[ahooks](https://ahooks.js.org/zh-CN/hooks/use-request/basic)

###### 2.1 常用内置组件

- **View遇到的一些问题：**

1.**内容被遮挡或无法滚动**：
	有时父容器没设置好 `flex: 1`，导致子组件空间不足，出现遮挡或内容溢出。

2.`flex: 1`、`StyleSheet.absoluteFillObject` 用法容易混淆，导致组件不显示或遮挡。

 	`flex: 1`：让组件在父容器里**自动填满剩余空间**，适合做页面主区域布局。

​	`StyleSheet.absoluteFillObject`：让组件**绝对填满父容器**，通常用于地图、背景图等需要覆盖整个区域的场景。

​	`LocationPickerModal.js`里，`MapView` 用了 `style={styles.map}`，而 `styles.map`是 `StyleSheet.absoluteFillObject`，但外层 `View`没有 `flex: 1`，或者高度/宽度受限，导致地图显示异常。

- **Text 组件**

  1.嵌套在多个 View 或自定义组件里,可能会被父组件样式覆盖或者不生效

~~~javascript
<Text style={{
    fontWeight: 'bold',
    color: 'black',
    fontSize: 20,
}}>
    Pick Shop Location
</Text>
~~~

用 StyleSheet 单独定义样式，避免内联样式冲突。

**圆角效果只有在元素有背景色或边框时才能看到**

~~~javascript
const styles = StyleSheet.create({
    container: {
        ...StyleSheet.absoluteFillObject,
        height: 400,
        width: 400,
        justifyContent: 'center',
        alignItems: 'center',
    },
    text: {
        fontWeight: 'bold',
    		color: 'black',
    		fontSize: 20,
    },
});
~~~

**键盘覆盖页面设置：**

AndroidManifest.xml中修改：adjustResize->asjustPan，在填写表单时就不会挤压表单

~~~xml
<Activity>
  android:windowSoftInputMode="adjustPan"
</Activity>
~~~



- **ScrollView**
  - **滚动区域不生效**：`flex: 1` 和 `contentContainerStyle` 配合不当，导致内容无法滚动。
  - **嵌套 FlatList/ScrollView**：多层嵌套时滚动冲突。

正确写法：

~~~javascript
<ScrollView
  style={{ flex: 1 }}
  contentContainerStyle={{ padding: 16 }}
>
  {/* 内容 */}
</ScrollView>
~~~

~~~javascript
<ScrollView style={{ flex: 1 }}>
  {/* 其他内容 */}
  <FlatList
    scrollEnabled={false} // 禁止内层滚动,可以解决与外层滚动的冲突
    data={data}
    renderItem={...}
  />
</ScrollView>
~~~



###### 2.2 第三方组件库

​	**使用第三方组件时需要查阅官方文档，进行依赖的安装以及配置，需要解决依赖冲突，版本不兼容等问题**

- icons出现图标不显示，原因：import 时为正确导入@react-native-vector-icons/inoicons，应检查 import 和组件命名，确保和库文档一致，以及官方有react-native-vector-icons库，与前缀@不是相同的，需要辨别书写。
- 依赖冲突（如 @amap 和 amap）
  - **原因**：项目里同时安装了两个类似的高德地图库，导致原生模块注册重复（如 `AMapCircle`），出现程序崩溃退出。
  - **解决方法**：只保留一个地图库，卸载多余依赖，彻底清理 node_modules 和 android/build，再重新编译。注意把相关导入代码书写正确，否则依然编译错误。
- 使用第三方组件库时引用需要加{},否则不生效，比如 `import {AMapSdk} from 'react-native-amap3d'`
- `react-native-amap3d` 在 Modal 关闭时资源释放不彻底，导致闪退:

**高德地图原生 SDK 在销毁地图引擎时崩溃了。**
这不是 JS 代码问题，是 react-native-amap3d 或高德地图原生库的 bug，尤其是在 Modal 里动态卸载 `<MapView />` 时。

**主要原因**：**高德地图原生 SDK 在 Modal 关闭时，MapView 组件被卸载，原生资源释放顺序或时机有 bug，导致 native 崩溃。**

**解决方案：**

1.更新最新amap

2.在`project/android/app/src/main/AndroidManifest.xml`的`application` 节点下新增

~~~xml
<Application
android:allowNativeHeapPointerTagging="false">
***其他代码***
</Application>
~~~



###### 2.3 自定义组件开发与复用

复用按钮组件：

~~~javascript
import { View, Text, TouchableOpacity } from 'react-native';
import React from 'react';
import Ionicons from 'react-native-vector-icons/Ionicons';


export default function SelectionComp({ extraStyle, image, label, onPress, checked }) {
    return (
        <TouchableOpacity style={{ flex: 1 }} onPress={() => onPress()}>
            <View style={[
                {
                    borderColor: '#BEC2C3',
                    borderWidth: 1,
                    paddingHorizontal: 15,
                    paddingVertical: 10,
                    borderRadius: 20,
                    flexDirection: 'row',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                },
                extraStyle,
            ]}>
                <View>
                    <Text style={{color:'#494a4a'}}>{label}</Text>
                </View>
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                    {checked ?
                        <Ionicons
                            name='checkmark-circle'
                            iconStyle='solid'
                            color={'green'}
                            size={20}
                            style={{ marginRight: 10 }}
                        /> : null}
                    {image}
                </View>
            </View>
        </TouchableOpacity>
    );
}
~~~

在MyShopScreen代码中复用，只需传递不同参数，就能满足不同业务场景：

~~~javascript
import SelectionComp from '../../components/SelectionComp';
// ...其他 import

export default function MyShopScreen({ navigation }) {
    // ...省略部分状态和方法

    return (
        <View style={{ flex: 1 }}>
            {/* ...其他页面内容 */}
            <View style={{ flex: 1, padding: 15 }}>
                {/* 统一输入框 */}
                <FormInputText placeholder={'Name'} />
                <FormInputText placeholder={'Email'} extraStyle={{ marginTop: 10 }} />
                <FormInputText placeholder={'Phone'} extraStyle={{ marginTop: 10 }} />
                <FormInputText placeholder={'Address'} extraStyle={{ marginTop: 10 }} />

                {/* 复用 SelectionComp 组件，传递不同的 props 实现不同功能 */}
                <SelectionComp
                    label={'Upload Shop Image'}
                    image={<Ionicons name='image-sharp' size={20} />}
                    extraStyle={{ marginTop: 20 }}
                    onPress={() => pickImageFromGallery()}
                    checked={shopImage ? true : false}
                />
                <SelectionComp
                    label={'Upload Shop Owner Image'}
                    image={<Ionicons name='image-sharp' size={20} />}
                    extraStyle={{ marginTop: 20 }}
                    onPress={() => pickShopOwnerImageFromGallery()}
                    checked={shopOwnerImage ? true : false}
                />
                <SelectionComp
                    label={shopCategory === undefined ? 'Select Category' : 'Selected Category - ' + shopCategory}
                    image={<Ionicons name='chevron-down' size={21} />}
                    extraStyle={{ marginTop: 20 }}
                    onPress={() => refRBSheet.current.open()}
                />
                <SelectionComp
                    label={'Select Shop Location'}
                    image={<Ionicons name='location-sharp' size={21} />}
                    extraStyle={{ marginTop: 20 }}
                    onPress={() => console.log('Press')}
                />
                <SelectionComp
                    label={shopOpenTime === undefined ? 'Open Time' : 'Open Time - ' + shopOpenTime}
                    image={<Ionicons name='time' size={18} />}
                    extraStyle={{ marginTop: 20 }}
                    onPress={() => {
                        setCurrentTimeOption('open');
                        setOpenDatePicker(true);
                    }}
                    checked={shopOpenTime ? true : false}
                />
                <SelectionComp
                    label={shopCloseTime === undefined ? 'Close Time' : 'Close Time - ' + shopCloseTime}
                    image={<Ionicons name='time' size={18} />}
                    extraStyle={{ marginTop: 20 }}
                    onPress={() => {
                        setCurrentTimeOption('close');
                        setOpenDatePicker(true);
                    }}
                    checked={shopCloseTime ? true : false}
                />
            </View>
            {/* ...其他页面内容 */}
        </View>
    );
}
~~~



##### 3. React Hooks 学习

- 3.1 useState、useEffect等基础学习

**useState**

用来声明和管理组件里的状态变量。
比如：

~~~javascript
const [showLocation, setShowLocation] = useState(false);
const [shopImage, setshopImage] = useState();
~~~

用 setXXX 修改状态，状态变了页面会自动刷新。

**useEffect**

用来做副作用，比如页面初始化、请求数据等。
比如：

~~~javascript
useEffect(() => {
 getUserData();
}, []);
~~~

依赖数组是 []，只在页面第一次加载时执行一次。

**useRef**

用来获取组件实例或者保存,不会引起页面刷新的变量。
比如：

~~~javascript
const refRBSheet = useRef();
~~~

可以用 refRBSheet.current 调用底部弹窗的方法。

在编写的demo中的使用:

~~~javascript
//MyShopScreen
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StatusBar, Dimensions, TouchableOpacity } from 'react-native';
import AppToolBar from '../../components/AppToolBar';
import RBSheet from 'react-native-raw-bottom-sheet';
import LocationPickerModal from '../../modals/LocationPickerModal';
import SelectionComp from '../../components/SelectionComp';
import Ionicons from 'react-native-vector-icons/Ionicons';
import DatePicker from 'react-native-date-picker';
import { formatDate } from '../../config/datePicker';

export default function MyShopScreen({ navigation }) {
    // 1. useState 用于管理各种状态
    const [user, setUser] = useState();
    const [shopImage, setshopImage] = useState();
    const [shopOwnerImage, setShopOwnerImage] = useState();
    const [shopCategory, setshopCategory] = useState();
    const [showLocation, setShowLocation] = useState(false);
    const [openDatePicker, setOpenDatePicker] = useState(false);
    const [shopOpenTime, setShopOpenTime] = useState();
    const [shopCloseTime, setShopCloseTime] = useState();
    const [currentTimeOption, setCurrentTimeOption] = useState();

    // 2. useRef 用于获取底部弹窗实例
    const refRBSheet = useRef();

    // 3. useEffect 用于初始化数据
    useEffect(() => {
        getUserData();
    }, []);

    // 业务相关函数略...

    // 4. 结合 useState/useRef 的业务组件
    const SelectGategoryBs = () => (
        <RBSheet ref={refRBSheet} ...>
            {/* ...内容略... */}
        </RBSheet>
    );

    return (
        <View style={{ flex: 1 }}>
            <StatusBar backgroundColor="#e3d2c2" barStyle="light-content" />
            <AppToolBar navigation={navigation} label={"MyShop"} />
            <SelectGategoryBs />
            {/* 5. 用 useState 控制弹窗显示 */}
            {showLocation && (
                <LocationPickerModal visible={true} onclose={() => setShowLocation(false)} />
            )}
            <DatePicker
                modal
                mode='time'
                open={openDatePicker}
                date={new Date()}
                onConfirm={(date) => {
                    setOpenDatePicker(false)
                    if (currentTimeOption === 'open') {
                        setShopOpenTime(formatDate(date.getHours() + ':' + date.getMinutes()));
                    } else if (currentTimeOption === 'close') {
                        setShopCloseTime(formatDate(date.getHours() + ':' + date.getMinutes()));
                    }
                }}
                onCancel={() => setOpenDatePicker(false)}
            />
            {/* 其他表单和业务内容略 */}
        </View>
    );
}
~~~

**useCallback**

**作用**：返回一个记忆化的回调函数，只有依赖变化时才会重新生成。

~~~javascript
const handleSelect = useCallback(() => {

  setShowLocation(true);

}, []);
~~~

- 用于优化性能，避免子组件重复渲染。
- 传递给子组件的事件处理函数。

**useMemo**

**作用**：返回一个记忆化的值，只有依赖变化时才会重新计算，用于优化性能，避免不必要的重复计算，处理复杂计算或大数据量筛选。

~~~javascript
const filteredCategory = useMemo(() => {
  return CategoryLs.filter(item => item.name.includes(searchText));
}, [searchText]);
~~~



- 3.2 自定义 Hook 的编写与应用

###### React Native 动画与状态管理笔记

**1. Animated.Value 与 scrollx**

在 React Native 中，`Animated.Value` 用于创建可动画驱动的数值。比如：

```js
const scrollx = new Animated.Value(0);
```

这里的 `0` 是动画值的初始值，表示动画变量从 0 开始变化。该值一般用来监听组件的滑动偏移或驱动其他动画属性。

当用分页的 FlatList 时，`scrollx` 可以反映当前横向滚动距离，配合 `Animated.event`，实现滑动时的动态动画效果。

**2. useRef 的作用和使用场景**

`useRef` 是 React（包括 React Native）提供的 Hook，用来创建一个持久且可变的引用对象，结构是 `{ current: 初始值 }`。

修改 `.current` 不会触发组件重新渲染，这使得它适合用来保存：

- 组件实例引用，例如 FlatList 的 `ref`，用于调用滚动等方法。
- 动画对象，例如 `Animated.Value`，保证动画值在组件生命周期内唯一且持续。
- 需要跨渲染周期保存但不直接影响 UI 的数据，比如定时器 ID、缓存值等。

与 `useState` 不同的是，`useState` 修改状态会导致组件重新渲染，而 `useRef` 修改 `.current` 不会。

**3. useRef 与 useState 的区别**

`useState` 用于管理状态，状态改变后组件会重新渲染，这适合 UI 需要响应的变量。典型如计数器、输入框内容、接口数据等。

而 `useRef` 用来保存不影响 UI 展示的可变值，比如动画值、引用、定时器 ID 等。它能避免不必要的渲染，提升性能。

总结来说，凡是需要影响界面显示的值，使用 `useState`；凡是纯粹数据缓存或引用，使用 `useRef`。

**4. FlatList 滚动监听与分页指示器的实现**

在实现分页指示器时，经常用 `Animated.Value` 来监听 FlatList 的滚动偏移：

```js
const scrollx = useRef(new Animated.Value(0)).current;

<Animated.FlatList
  onScroll={Animated.event(
    [{ nativeEvent: { contentOffset: { x: scrollx } } }],
    { useNativeDriver: false }
  )}
  pagingEnabled
  horizontal
  // 其他属性
/>
```

这里 `nativeEvent.contentOffset.x` 表示横向滚动距离，绑定到动画值 `scrollx`，通过它驱动指示器的动画。

分页指示器组件中，每个圆点的动画通过插值实现：

```js
const inputRange = [(i - 1) * width, i * width, (i + 1) * width];
const scale = scrollx.interpolate({
  inputRange,
  outputRange: [0.8, 1.4, 0.8],
  extrapolate: 'clamp',
});
const opacity = scrollx.interpolate({
  inputRange,
  outputRange: [0.6, 0.9, 0.8],
  extrapolate: 'clamp',
});
```

这里 `inputRange` 中的三个值分别代表当前页前一页、当前页和后一页的滑动偏移位置，`scrollx` 在该区间内变化时，动画属性平滑过渡。

`extrapolate: 'clamp'` 确保当滚动超出范围时，动画不会继续扩展。

**5. transform 和 opacity 等动画属性的写法**

在给样式添加动画时，`transform` 属性必须是数组，因为它支持多重动画组合，如缩放、旋转、平移：

```js
transform: [{ scale }]
```

而 `opacity` 等普通样式属性，直接写成数值或动画值即可：

```js
opacity: opacity
```

不需要也不应该用数组包裹，否则动画不会生效。

**6. FlatList 引用与控制**

使用 `useRef` 创建一个引用，绑定 FlatList：

```js
const slideRef = useRef(null);

<FlatList ref={slideRef} />
```

通过引用可以调用 FlatList 的方法，如滚动到指定页：

```js
slideRef.current.scrollToIndex({ index: currentIndex + 1 });
```

这方便实现“下一页”等交互功能。

**7. 什么时候需要重新渲染，什么时候不需要**

只要变量会影响 UI 展示，比如计数、文本、颜色等，就需要用 `useState`，修改它会导致组件重新渲染。

而如果是纯粹用来缓存数据、不直接影响界面、或者引用组件实例，使用 `useRef`，修改不会触发渲染，避免不必要的性能开销。

**总结**

- `Animated.Value(0)` 用来创建带动画效果的数值，`0` 是初始值。
- `useRef` 用来创建持续不变的引用，保存不影响 UI 的数据或组件实例。
- `useState` 用来管理会影响 UI 显示的状态。
- 滚动监听通过绑定 FlatList 的 `nativeEvent.contentOffset.x` 到动画值实现。
- 分页指示器的动画通过 `scrollx.interpolate` 根据滑动位置平滑过渡。
- `transform` 是数组形式的样式，普通样式如 `opacity` 是直接数值。
- FlatList 通过 `useRef` 引用，可以调用滚动等方法实现交互。

------

- 3.3 生命周期与数据流管理

##### 4. 路由与导航

- 4.1 react-navigation 



- 4.2 Drawer、Stack、Tab 导航用法



- 4.3 页面参数传递与返回



##### 5. 原生模块与 Codegen

**学习文档**：

[RN-Native基础Bridge说明](https://pupumall.feishu.cn/wiki/P00PwQbR9ivVJPklAPNcw8zhnnc)

- 5.1 原生模块桥接原理

在高德地图中，由于amap不能够实现逆地理编码，所以此时需要按照高德地图文档去使用原生代码实现逆地理编码功能并桥接到RN（但是amap和3dmap有依赖冲突，这里花很多时间解决

​	(1) 首先是配置高德地图搜索SDK，分别在android/build.gradle和android/app/build.gradle进行官网指导的相关配置

~~~
//android/build.gradle
allprojects {
    repositories {
        //google()
        mavenCentral()

        // ✅ 添加高德的 Maven 仓库
        maven { url 'https://a.amap.com/android/sdk/maven' }
    }
}

//android/app/build.gradle
android{
	ndk {
            //设置支持的SO库架构（开发者可以根据需要，选择一个或多个平台的so）
            abiFilters  "armeabi-v7a", "arm64-v8a"
        }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    //3D地图so及jar,已经包含定位和搜索功能无需单独引用
    implementation 'com.amap.api:search:latest.integration'
     
}
~~~

​	(2) 在android/app/src/main/java/com/yteeeecommerce目录下创建java文件或者kt文件

~~~java
//AMapGeocodeModule.java
package com.yteeeecommerce;

import ...

public class AMapGeocodeModule extends ReactContextBaseJavaModule {
    private final ReactApplicationContext reactContext;

    public AMapGeocodeModule(ReactApplicationContext reactContext) {
        super(reactContext);
        this.reactContext = reactContext;
    }

    @NonNull
    @Override
    public String getName() {
        return "AMapGeocodeModule";
    }
		
  	// 获取地址信息
    @ReactMethod
    public void getAddress(double latitude, double longitude, Promise promise) {
        try {
            GeocodeSearch geocodeSearch = new GeocodeSearch(reactContext);
            geocodeSearch.setOnGeocodeSearchListener(new GeocodeSearch.OnGeocodeSearchListener() {
                @Override
                public void onRegeocodeSearched(RegeocodeResult result, int rCode) {
                    Log.d("AMapGeocodeModule", "onRegeocodeSearched: rCode = " + rCode);
                    if (rCode == AMapException.CODE_AMAP_SUCCESS &&
                        result.getRegeocodeAddress() != null) {
                        String address = result.getRegeocodeAddress().getFormatAddress();
                        promise.resolve(address);
                    } else {
                        promise.reject("AMAP_ERROR", "逆地理编码失败，错误码: " + rCode);
                    }
                }

                @Override
                public void onGeocodeSearched(GeocodeResult result, int rCode) {}
            });

            LatLonPoint point = new LatLonPoint(latitude, longitude);
            RegeocodeQuery query = new RegeocodeQuery(point, 200, GeocodeSearch.AMAP);
            geocodeSearch.getFromLocationAsyn(query);
        } catch (Exception e) {
            promise.reject("AMAP_EXCEPTION", e.getMessage());
        }
    }
}

~~~

~~~java
//AmapGeocodePackage.java
package com.yteeeecommerce;

import ...

//这个类用于注册 AMapGeocodeModule 模块到 React Native
public class AMapGeocodePackage implements ReactPackage {
    @Override
    public List<NativeModule> createNativeModules(ReactApplicationContext context) {
        return Arrays.<NativeModule>asList(new AMapGeocodeModule(context));
    }

    @Override
    public List<ViewManager> createViewManagers(ReactApplicationContext context) {
        return Collections.emptyList();
    }
}

~~~

然后在MainApplication.kt中注册模块,还需再onCreate()中初始化

~~~kotlin
//顶部导入模块
import com.yteeeecommerce.AMapGeocodePackage
/*其他导入内容*/

//注册
class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List<ReactPackage> =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
              add(AMapGeocodePackage())//添加这一行
            }

        //其他代码
        
    override fun onCreate() {
    	super.onCreate()

    	// ✅ 高德地图隐私合规初始化
    	ServiceSettings.updatePrivacyShow(this, true, true);
    	ServiceSettings.updatePrivacyAgree(this, true);
    
    	loadReactNative(this)
      }
}

~~~

​	(3)在项目中使用

~~~javascript
import {  NativeModules } from 'react-native';
/*其他*/

const { AMapGeocodeModule } = NativeModules;

async function getAddress() {
        try {
            const address = await AMapGeocodeModule.getAddress(marker.latitude, marker.longitude);
            console.log('地址', address);
        } catch (error) {
            console.error('逆地理编码失败', error);
        }
    }
~~~



- 5.2 Codegen 自动生成原生桥接代码





- 5.3 自定义原生组件（Android/iOS）





- 5.4 原生依赖管理与 ABI 兼容性





##### 6. 权限与平台特性

- 6.1 Android权限申请（如定位、存储、相机）

**权限声明（AndroidManifest.xml）**

在 [android/app/src/main/AndroidManifest.xml](vscode-file://vscode-app/private/var/folders/zd/1f6lczvn43g25g0y_tbs__hm0000gn/T/AppTranslocation/54DE840E-F764-4ABF-9A7A-C46E274080C2/d/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 里加上需要的权限：

~~~xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.CAMERA" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
~~~

**动态权限申请（JS代码里）**

用 [PermissionsAndroid](vscode-file://vscode-app/private/var/folders/zd/1f6lczvn43g25g0y_tbs__hm0000gn/T/AppTranslocation/54DE840E-F764-4ABF-9A7A-C46E274080C2/d/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 申请敏感权限（如定位、存储、相机），否则 Android 6.0+ 上会被拒绝。

**定位权限申请**

~~~javascript
import { PermissionsAndroid, Platform } from 'react-native';

async function requestLocationPermission() {
  if (Platform.OS === 'android') {
    try {
      const granted = await PermissionsAndroid.request(
        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
        {
          title: '定位权限',
          message: '需要获取您的定位权限以显示地图位置',
          buttonNeutral: '稍后询问',
          buttonNegative: '拒绝',
          buttonPositive: '允许',
        },
      );
      if (granted === PermissionsAndroid.RESULTS.GRANTED) {
        console.log('定位权限已授权');
      } else {
        console.log('定位权限被拒绝');
      }
    } catch (err) {
      console.warn(err);
    }
  }
}
~~~

**用法：**

~~~javascript
// 需要用定位前调用
await requestLocationPermission();
~~~

 **常用权限**

- **相机权限**：PermissionsAndroid.PERMISSIONS.CAMERA
- **读存储权限**：PermissionsAndroid.PERMISSIONS.READ_EXTERNAL_STORAGE
- **写存储权限**：PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE

**申请方式同上，只需把 PERMISSIONS.XXX换成对应权限即可。**

- 6.2 Platform 模块与平台差异处理

**Platform模块作用**

Platform 是 React Native 提供的一个模块，用于判断当前运行环境是 Android 还是 iOS，从而实现平台差异化处理。

**引入方式：**

~~~javascript
import { Platform } from 'react-native';
~~~

**常用判断：**

~~~javascript
if (Platform.OS === 'android') {
 
}

if (Platform.OS === 'ios') {
}
~~~

**平台差异化赋值**

**比如高德地图key,**Platform.select 可以根据不同平台返回不同的值。

~~~javascript
const amapKey = Platform.select({
 android: "你的安卓key",
 ios: "你的iOS key",
});
~~~

##### 7. 调试与性能优化

- 7.1 Metro 调试与缓存清理
- 7.2 Chrome/Flipper 调试工具
- 7.3 adb logcat/Android Studio Logcat 原生日志分析
- 7.4 性能优化技巧（列表优化、图片优化等）

##### 8. 项目结构与工程管理

- 8.1 目录结构设计
- 8.2 多环境配置（dev/prod）
- 8.3 脚本与自动化（如 fastlane、CI/CD）

##### 9. 常见问题与解决方案

- 9.1 依赖冲突与原生崩溃排查
- 9.2 常见报错及处理方法
- 9.3 社区资源与文档查找技巧



#### JS、TS

##### 总体理解

| 项目         | JavaScript（JS）       | TypeScript（TS）                      |
| ------------ | ---------------------- | ------------------------------------- |
| 类型系统     | 动态类型（运行时检查） | 静态类型（编译时检查）                |
| 错误发现     | 运行时报错             | 写代码时报错（类型推断 + 编辑器提示） |
| 代码提示     | 几乎没有               | 智能补全、跳转、重构能力强            |
| 项目可维护性 | 较差，易出错           | 更可靠，更适合大型项目                |

对比差异

| 章节内容                      | JavaScript 支持 | TypeScript 支持 | 说明                                   |
| ----------------------------- | --------------- | --------------- | -------------------------------------- |
| 5. 联合类型（`string          | number`）       | ❌ 不支持        | ✅ 支持                                 |
| 5. 类型别名（`type X = ...`） | ❌ 不支持        | ✅ 支持          | JS 没有类型系统，TS 可封装复杂类型     |
| 6. 类型断言（`as T`）         | ❌ 不支持        | ✅ 支持          | JS 无法断言类型，TS 可手动指定类型     |
| 7. 泛型（`<T>`）              | ❌ 不支持        | ✅ 支持          | TS 支持泛型，JS 无法做到类型通用复用   |
| 8. 类的访问修饰符             | ❌（ES 提案中）  | ✅ 支持          | TS 完整支持 `private/protected` 等特性 |
| 9. 工具类型（`Partial<T>`）   | ❌ 不支持        | ✅ 支持          | JS 完全没有，TS 内置工具可简化开发     |



##### 1.变量声明与注释

js：

~~~javascript
let name = 'Alice';
let age = 25;
~~~

Ts:

~~~typescript
let name: string = 'Alice';
let age: number = 25;
~~~

- 类型显式：`name: string`

- 类型推断：即使不写，TS 也能自动推断

~~~typescript
let isOnline = true; // 推断为 boolean
~~~

##### 2.函数：参数与返回值类型

js：

~~~javascript
function greet(name) {
  return 'Hello, ' + name;
}
~~~

ts:

~~~typescript
function greet(name: string): string {
  return 'Hello, ' + name;
}
~~~

参数和返回值必须明确类型，支持可选参数、默认参数

~~~typescript
function sayHi(name?: string) {
  return `Hi, ${name ?? 'Guest'}`;
}
~~~

##### 3.对象与接口（interface）

Js:

~~~javascript
const user = {
  name: 'Tom',
  age: 30,
};
~~~

Ts:(推荐定义接口)

~~~typescript
interface User {
  name: string;
  age: number;
}

const user: User = {
  name: 'Tom',
  age: 30,
};
~~~

- 接口 interface 用于规范对象结构

- 可选属性：`age?: number`

- 只读属性：`readonly id: string`

##### 4.数组与元组

JS 写法：

```javascript
let nums = [1, 2, 3];
```

TS 写法：

```typescript
let nums: number[] = [1, 2, 3];
let names: Array<string> = ['a', 'b'];

// 元组：固定类型和长度
let tuple: [string, number] = ['Tom', 20];
```

精确控制每个元素的类型，元组常用于返回多值

##### 5.联合类型与类型别名

t s:

~~~typescript
let id: string | number; // 可以是字符串或数字

type Status = 'success' | 'error' | 'loading';

let state: Status = 'success';
~~~

- **联合类型**（多个类型）：灵活应对参数多样性

- **类型别名**：简化复杂类型定义

##### 6.类型断言（Type Assertion）

t s:

~~~typescript
let value: any = 'hello';
let len = (value as string).length;
~~~

或：

~~~typescript
let len = (<string>value).length;
~~~

跳过推断，常用于类型不明确、但你清楚情况时

##### 7.泛型（Generic）

Ts:(类似于c++的模板)

~~~typescript
function echo<T>(arg: T): T {
  return arg;
}

echo<number>(123);
echo<string>('hello');
~~~

泛型让函数、接口支持多种类型，保持类型一致性，提高复用性

##### 8.类与访问修饰符

Ts:

~~~typescript
class Person {
  public name: string;
  private age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet() {
    return `Hi, I'm ${this.name}`;
  }
}
~~~

- `public`：默认，外部可访问

- `private`：仅限类内访问

- `protected`：类及其子类可访问

- 支持抽象类、接口实现等面向对象特性

##### Utility Types

| 工具类型      | 含义                    |
| ------------- | ----------------------- |
| `Partial<T>`  | 将 T 的所有属性设为可选 |
| `Required<T>` | 将 T 的所有属性设为必填 |
| `Pick<T, K>`  | 取 T 的某些属性         |
| `Omit<T, K>`  | 排除 T 的某些属性       |
| `Readonly<T>` | 所有属性变为只读        |

Ts:

~~~typescript
interface User {
  id: number;
  name: string;
  email: string;
}

type UserPreview = Pick<User, 'id' | 'name'>;
type OptionalUser = Partial<User>;
~~~



#### Charles的使用



#### sourceTree的使用



#### 学习心得：

这个月对于RN的学习，从单个组件到简单功能组合，试着啃了不少小模块，过程稍微有些磕绊，记几点具体的感受：

一、Hook

​	刚开始用 useState 和 useEffect ，纯属跟着例子写——计数器用 useState 存数字，请求数据在 useEffect 里写。做onboarding页面时，需要记录“是否首次打开”，用 useState 存状态，配合 useEffect 读取 AsyncStorage 里的标记，慢慢明白： useState 是暂存当前页面的数据， useEffect 是处理页面加载/数据变化时的操作。

​	用Vue时习惯了 v-if 控制显示、 v-for 循环列表，到RN里发现逻辑没变，写法却换了：条件渲染用 `{isShow && <View />}` ，列表渲染靠 `FlatList` ，虽然一开始觉得不如指令直观，但写多了发现，这种“JS逻辑直接嵌入UI”的方式其实更灵活——比如给 FlatList 的 renderItem 加条件判断，根据item类型渲染不同组件，比Vue里在 v-for 里嵌套 v-if 思路更清晰。

​	在RN里处理状态和副作用，确实和Vue的思路有微妙差别，但用熟了会觉得更直接——尤其是状态管理和副作用的绑定，逻辑链条很清晰。

​	就拿做Toast组件来说，用 useState 管理显示状态（ visible ）和文本（ message ），再用 useEffect 监听 visible 的变化：当 visible 从 false 变成 true 时，启动一个定时器，几秒后自动把 visible 切回 false 。整个逻辑写下来就是：

~~~javascript
const [visible, setVisible] = useState(false);
const [message, setMessage] = useState('');

useEffect(() => {
  if (visible) {
    const timer = setTimeout(() => setVisible(false), 2000);
    return () => clearTimeout(timer); // 组件卸载时清定时器，避免内存泄漏
  }
}, [visible]); // 只在visible变化时触发，精准控制执行时机
~~~


​	这种写法的好处是，副作用（定时器）和依赖（visible）直接绑定，不像Vue里需要在 mounted 里写启动逻辑，再在 watch 里处理变化——RN里用一个 useEffect 就把“显示时启动定时器、隐藏时清除、依赖变化时重新执行”全搞定了，逻辑收拢在一块，找问题时也更容易定位。

​	而且 const [count, setCount] 这种声明式定义，状态和修改函数成对出现，用的时候不用想 this 指向，直接调用 setCount 就行，比如Toast的显示方法：

~~~java
const showToast = (text) => {
  setMessage(text);
  setVisible(true);
};
~~~


​	调用时直接 showToast('操作成功') ，比Vue里 this.message = text; this.visible = true 少了 this 的干扰，写起来更清爽。刚开始确实会怀念Vue的“响应式自动更新”，但RN这种“手动声明状态+显式触发更新”的方式，虽然多写几行，却能让状态流转的每一步都更可控，尤其在处理复杂交互时，不容易出现“不知道哪里改了状态”的情况。

二、第三方API：

​	谷歌登录看着简单，实际要注意的细节不少： GoogleSignin.configure 里的 scopes 得按需求填，不然拿不到用户邮箱；登录成功后， user 对象里的 idToken 和 accessToken 要区分开，调后端接口时别传错。第一次集成时，就因为没处理“用户取消登录”的回调，导致页面卡死，后来才知道 signIn 返回的 promise 要加 catch 捕获错误。

​	高德地图更考验耐心：安装了几个rn的第三方库依赖后发现会发生冲突，但是无法只依赖其中一个库就实现显示地图和获取逆地理编码，所以这类功能模块一般使用原生集成再与RN桥接的办法。给地图加弹窗时，用 Modal 组件包裹内容，再通过 onPress 事件控制 visible 状态，虽然是基础组件组合，但和地图联动起来，有种“功能活了”的感觉。Vue里用地图组件只需引JS库，RN里却要处理 MapView 的原生渲染，比如给地图加标记点，Vue是调用API方法，RN里则是在 MapView 里嵌套 Marker 组件，这种“组件化嵌套”的思路反而和Vue的组件复用理念更像，上手比想象中快。

三、复用与交互

​	写加载器（Loader）和Toast，试着封装成自定义组件：Loader接收 visible 参数控制显示隐藏，Toast传 message 和 duration ，用 useEffect 控制自动消失。在页面里用 `<Loader visible={loading} /> `,同时复用的还有图片弹窗，还有表单按钮之类的。

​	RN里用 Animated 库做动画，刚开始觉得API太繁琐，定义 Animated.Value 、写 scroll 动画、绑定到组件样式，不过通过状态驱动样式变化，拆解逻辑逐步实现即可。

四、最大的收获：理清代码书写思路

做登录、地图、侧边栏的页面等需求，下意识拆成小步骤：先搭页面结构（用 View 和 Flex 布局），再加状态管理（ useState 存登录状态、地图坐标），然后集成第三方API（谷歌登录、高德地图），最后补交互（侧边栏展开/收起、Toast提示）。

有时会犯低级错误（比如 AsyncStorage 忘了 JSON.stringify 数据，导致读取时出错）。对于状态管理Redux 等还不是很熟练，但是页面多了之后，用 useState 传参有点绕，希望能把组件间的数据流转理得更顺一点。



## 第二个月： 

### 1、熟悉Android项目、项目结构、项目配置，掌握kotlin语言基础及语法 

### 2、熟悉安卓代码规范、RN代码规范，可进行简单的项目代码阅读及理解 

### 3、整理学习笔记并总结心得体会 



#### kotlin语法基础

[kotlin教程](https://www.runoob.com/kotlin/kotlin-basic-syntax.html)

基础语法：

函数返回值：

~~~kotlin
public fun sum(a: Int, b: Int): Int = a + b   // public 方法则必须明确写出返回类型

// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：
public fun printSum(a: Int, b: Int) { 
    print(a + b)
}
~~~

可变长参数函数：用 **vararg** 关键字进行标识

~~~kotlin
fun vars(vararg v:Int){
    for(vt in v){
        print(vt)
    }
}

// 测试
fun main(args: Array<String>) {
    vars(1,2,3,4,5)  // 输出12345
}
~~~

NULL检查机制:对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 **null** 或配合 **?:** 做空判断处理

~~~kotlin
//类型后面加?表示可为空
var age: String? = "23" 
//抛出空指针异常
val ages = age!!.toInt()
//不做处理返回 null
val ages1 = age?.toInt()
//age为空返回-1
val ages2 = age?.toInt() ?: -1

~~~

类型检测及自动类型转换:可以使用 **is** 运算符检测一个对象是否是指定类型的实例(类似于 Java 中的 instanceof 关键字)。

~~~kotlin
fun getStringLength(obj: Any): Int? {
  if (obj is String) {
    // 做过类型判断以后，obj会被系统自动转换为String类型
    return obj.length 
  }
}
~~~

区间：

~~~kotlin
for (i in 1..4) print(i) // 输出“1234”

for (i in 4..1) print(i) // 什么都不输出

if (i in 1..10) { // 等同于 1 <= i && i <= 10
    println(i)
}

// 使用 step 指定步长
for (i in 1..4 step 2) print(i) // 输出“13”

for (i in 4 downTo 1 step 2) print(i) // 输出“42”


// 使用 until 函数排除结束元素
for (i in 1 until 10) {   // i in [1, 10) 排除了 10
     println(i)
}
~~~

Val：不可变变量，声明时如果不初始化，需要定义类型

var：可变变量

Lambda 

~~~kotlin
val sumLambda: (Int, Int) -> Int = {x,y -> x+y}
println(sumLambda(1,2))  // 输出 3
~~~

字符串模板:

~~~kotlin
$ 表示一个变量名或者变量值
$varName 表示变量值
${varName.fun()} 表示变量的方法返回值:
~~~

String 可以通过 trimMargin() 方法来删除多余的空白。

~~~kotlin
fun main(args: Array<String>) {
    val text = """
    |多行字符串
    |菜鸟教程
    |多行字符串
    |Runoob
    """.trimMargin()
    println(text)    // 前置空格删除了
}
~~~

原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：

~~~kotlin
fun main(args: Array<String>) {
    val price = """
    ${'$'}9.99
    """
    println(price)  // 求值结果为 $9.99
}
~~~

抽象类

~~~kotlin
open class Animal {
    open fun speak() {
        println("Some sound")
    }
}

abstract class Dog : Animal() {
    override abstract fun speak()
}

class Bulldog : Dog() {
    override fun speak() {
        println("Woof!")
    }
}
~~~

内部类

~~~kotlin
class Outer {
    private val bar: Int = 1
    var v = "成员属性"
    /**嵌套内部类**/
    inner class Inner {
        fun foo() = bar  // 访问外部类成员
        fun innerTest() {
            var o = this@Outer //获取外部类的成员变量
            println("内部类可以引用外部类的成员，例如：" + o.v)
        }
    }
}

fun main(args: Array<String>) {
    val demo = Outer().Inner().foo()
    println(demo) //   1
    val demo2 = Outer().Inner().innerTest()   
    println(demo2)   // 内部类可以引用外部类的成员，例如：成员属性
}
~~~

匿名内部类：

~~~kotlin
class Test {
    var v = "成员属性"

    fun setInterFace(test: TestInterFace) {
        test.test()
    }
}

/**
 * 定义接口
 */
interface TestInterFace {
    fun test()
}

fun main(args: Array<String>) {
    var test = Test()

    /**
     * 采用对象表达式来创建接口对象，即匿名内部类的实例。
     */
    test.setInterFace(object : TestInterFace {
        override fun test() {
            println("对象表达式创建匿名内部类的实例")
        }
    })
}
~~~

使用：比如点击事件回掉

~~~kotlin
button.setOnClickListener(object : View.OnClickListener {
    override fun onClick(v: View?) {
        println("点击事件")
    }
})
~~~

类的修饰符包括 classModifier 和_accessModifier_:

- classModifier: 类属性修饰符，标示类本身特性。

  ```
  abstract    // 抽象类  
  final       // 类不可继承，默认属性
  enum        // 枚举类
  open        // 类可继承，类默认是final的
  annotation  // 注解类
  ```

- accessModifier: 访问权限修饰符

  ```
  private    // 仅在同一个文件中可见
  protected  // 同一个文件中或子类可见
  public     // 所有调用的地方都可见
  internal   // 同一个模块中可见
  ```

🔧 Android 中常见注解示例 annotation 

| 注解                             | 作用                          |
| -------------------------------- | ----------------------------- |
| `@Override`                      | 表示方法是重写父类/接口的方法 |
| `@Inject`                        | 用于依赖注入                  |
| `@SerializedName("json_key")`    | Gson 序列化字段映射           |
| `@NonNull` / `@Nullable`         | 提示某字段是否允许为 null     |
| `@GET("/api")` / `@POST("/api")` | Retrofit 网络请求注解         |
| `@BindView(R.id.xxx)`            | ButterKnife 绑定控件          |

 示例一：自定义注解 + 反射读取

✅ 1. 定义一个注解类

```kotlin
@Target(AnnotationTarget.CLASS) // 这个注解只能用于类上
@Retention(AnnotationRetention.RUNTIME) // 注解保留到运行时，可以反射获取
annotation class Info(val author: String, val version: Int)
```

✅ 2. 使用注解

```kotlin
@Info(author = "张三", version = 1)
class MyService
```

✅ 3. 通过反射读取注解信息

```kotlin
fun main() {
    val clazz = MyService::class
    val annotation = clazz.annotations.find { it is Info } as? Info
    if (annotation != null) {
        println("作者：${annotation.author}, 版本：${annotation.version}")
    }
}
```

**输出：**

```
作者：张三, 版本：1
```

📱 示例二：Android 中的常见注解（Retrofit）

✅ 定义接口 + 使用注解

```kotlin
interface ApiService {
    @GET("user/info")
    fun getUserInfo(): Call<User>

    @POST("user/update")
    fun updateUser(@Body user: User): Call<Response>
}
```

这些 `@GET`、`@POST`、`@Body` 其实都是注解类，用来告诉 **Retrofit 框架** 该方法和参数的意义。

Retrofit 内部会通过反射扫描这些注解并生成网络请求。

🧰 示例三：Gson 注解（数据解析）

✅ 使用注解类映射 JSON 字段

```kotlin
data class User(
    @SerializedName("user_name") val name: String,
    @SerializedName("user_age") val age: Int
)
```

JSON：

```json
{
  "user_name": "李雷",
  "user_age": 30
}
```

`@SerializedName("xxx")` 是 Gson 框架定义的注解类，用来告诉它“JSON 的字段名”和 Kotlin 字段的映射关系。

🔄 示例四：ButterKnife 注解（绑定控件）

```java
@BindView(R.id.tv_title)
TextView title;

@OnClick(R.id.btn_submit)
public void onSubmitClick() {
    // 处理点击事件
}
```

ButterKnife 库通过注解自动帮你绑定控件，不用 `findViewById()`，提高效率。

✅ 总结一下

| 注解用途   | 示例                     | 注解类                        |
| ---------- | ------------------------ | ----------------------------- |
| 定义元数据 | `@Info(...)`             | 自定义                        |
| 网络请求   | `@GET`, `@POST`, `@Body` | Retrofit                      |
| JSON映射   | `@SerializedName`        | Gson                          |
| UI绑定     | `@BindView`, `@OnClick`  | ButterKnife                   |
| 空值控制   | `@NonNull`, `@Nullable`  | JetBrains/Support annotations |

------

主类没有主构造函数，次构造函数使用super关键字初始化基类

~~~kotlin
/**用户基类**/
open class Person(name:String){
    /**次级构造函数**/
    constructor(name:String,age:Int):this(name){
        //初始化
        println("-------基类次级构造函数---------")
    }
}

/**子类继承 Person 类**/
class Student:Person{

    /**次级构造函数**/
    constructor(name:String,age:Int,no:String,score:Int):super(name,age){
        println("-------继承类次级构造函数---------")
        println("学生名： ${name}")
        println("年龄： ${age}")
        println("学生号： ${no}")
        println("成绩： ${score}")
    }
}

fun main(args: Array<String>) {
    var s =  Student("Runoob", 18, "S12345", 89)
}
~~~

如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用 super 泛型去选择性地调用父类的实现。

```kotlin
open class A {
    open fun f () { print("A") }
    fun a() { print("a") }
}

interface B {
    fun f() { print("B") } //接口的成员变量默认是 open 的
    fun b() { print("b") }
}

class C() : A() , B{
    override fun f() {
        super<A>.f()//调用 A.f()
        super<B>.f()//调用 B.f()
    }
}

fun main(args: Array<String>) {
    val c =  C()
    c.f();

}
```

接口中的属性:接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：

~~~kotlin
interface MyInterface{
    var name:String //name 属性, 抽象的
}
 
class MyImpl:MyInterface{
    override var name: String = "runoob" //重写属性
}
~~~

扩展

~~~kotlin
fun receiverType.functionName(params){
    body
}

// 扩展函数 swap,调换不同位置的值
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1]     //  this 对应该列表
    this[index1] = this[index2]
    this[index2] = tmp
}

fun main(args: Array<String>) {

    val l = mutableListOf(1, 2, 3)
    // 位置 0 和 2 的值做了互换
    l.swap(0, 2) // 'swap()' 函数内的 'this' 将指向 'l' 的值

    println(l.toString())
}

~~~

扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的:

```kotlin
open class C

class D: C()

fun C.foo() = "c"   // 扩展函数 foo

fun D.foo() = "d"   // 扩展函数 foo

fun printFoo(c: C) {
    println(c.foo())  // 类型是 C 类
}

fun main(arg:Array<String>){
    printFoo(D())
}
```

实例执行输出结果为：

```kotlin
c
```

若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。

在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。

除了函数，Kotlin 也支持属性对属性进行扩展:

```
val <T> List<T>.lastIndex: Int
    get() = size - 1
 
```

扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。

```
val Foo.bar = 1 // 错误：扩展属性不能有初始化器
```

扩展属性只能被声明为 val.



密封类

密封类就是一种专门用来配合 when 语句使用的类，举个例子，假如在 Android 中我们有一个 view，我们现在想通过 when 语句设置针对 view 进行两种操作：显示和隐藏，那么就可以这样做：

```kotlin
sealed class UiOp {
    object Show: UiOp()
    object Hide: UiOp()
} 
fun execute(view: View, op: UiOp) = when (op) {
    UiOp.Show -> view.visibility = View.VISIBLE
    UiOp.Hide -> view.visibility = View.GONE
}
```

匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。

```kotlin
class C {
    // 私有函数，所以其返回类型是匿名对象类型
    private fun foo() = object {
        val x: String = "x"
    }

    // 公有函数，所以其返回类型是 Any
    fun publicFoo() = object {
        val x: String = "x"
    }

    fun bar() {
        val x1 = foo().x        // 没问题
        val x2 = publicFoo().x  // 错误：未能解析的引用“x”
    }
}
```

对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。

```kotlin
class Site {
    var name = "菜鸟教程"
    object DeskTop{
        var url = "www.runoob.com"
        fun showName(){
            print{"desk legs $name"} // 错误，不能访问到外部类的方法和变量
        }
    }
}
fun main(args: Array<String>) {
    var site = Site()
    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象
    Site.DeskTop.url // 正确
}
```

伴生对象

类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。

```
class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}

val instance = MyClass.create()   // 访问到对象的内部元素
```

我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名：

```
class MyClass {
    companion object {
    }
}

val x = MyClass.Companion
```

**注意：**一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。

委托：





##  第三个月： 

### 1、熟悉各个模块的业务，包含售前、售中、售后等模块业务 

### 2、熟悉需求开发流程，熟悉Meego、Marsenal、Figma平台使用流程，进行一个小需求开发 

### 3、整理学习笔记并总结心得体会

